name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Check SSH secrets
        run: |
          # Check for SSH_PRIVATE_KEY
          if [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "‚úÖ SSH_PRIVATE_KEY is set"
          elif [ -n "${{ secrets.SSH_KEY }}" ]; then
            echo "‚ö†Ô∏è SSH_PRIVATE_KEY not set, but SSH_KEY found. Will try to use it."
            echo "SSH_PRIVATE_KEY_ACTUAL=${{ secrets.SSH_KEY }}" >> $GITHUB_ENV
          else
            echo "‚ùå SSH_PRIVATE_KEY (or SSH_KEY) secret is not set"
            exit 1
          fi
          
          # Check for SERVER_IP
          if [ -n "${{ secrets.SERVER_IP }}" ]; then
             echo "‚úÖ SERVER_IP is set"
          elif [ -n "${{ secrets.SSH_HOST }}" ]; then
             echo "‚ö†Ô∏è SERVER_IP not set, but SSH_HOST found. Will try to use it."
             echo "SERVER_IP_ACTUAL=${{ secrets.SSH_HOST }}" >> $GITHUB_ENV
          else
             echo "‚ùå SERVER_IP (or SSH_HOST) secret is not set"
             exit 1
          fi
          
          if [ -z "${{ secrets.SSH_USER }}" ]; then
            echo "‚ùå SSH_USER secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "‚ùå DB_PASSWORD secret is not set"
            exit 1
          fi

      - name: Set environment variables
        run: |
          # Set defaults if not set by previous step fallback
          if [ -z "$SSH_PRIVATE_KEY_ACTUAL" ]; then
            echo "SSH_PRIVATE_KEY_ACTUAL=${{ secrets.SSH_PRIVATE_KEY }}" >> $GITHUB_ENV
          fi
          if [ -z "$SERVER_IP_ACTUAL" ]; then
            echo "SERVER_IP_ACTUAL=${{ secrets.SERVER_IP }}" >> $GITHUB_ENV
          fi

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.SSH_PRIVATE_KEY_ACTUAL }}
      
      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.SERVER_IP_ACTUAL }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
      
      - name: Deploy to server
        env:
          SERVER_IP: ${{ env.SERVER_IP_ACTUAL }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          set -e
          echo "üöÄ Starting deployment to production server..."
          
          # Deploy script that runs on the server
          ssh -o StrictHostKeyChecking=no ${SSH_USER}@${SERVER_IP} "DB_PASSWORD='${DB_PASSWORD}' bash -s" << 'DEPLOY_SCRIPT'
            set -e
            
            # --- Permission Check ---
            SUDO=""
            if ! docker ps >/dev/null 2>&1; then
                if sudo docker ps >/dev/null 2>&1; then
                    echo "‚ö†Ô∏è  User does not have docker permissions. Using sudo."
                    SUDO="sudo"
                else
                    echo "‚ùå User cannot run docker (tried with and without sudo)."
                    exit 1
                fi
            fi
            
            echo "üìÅ Changing to project directory..."
            # Try home dir, fallback only if needed
            cd /home/ubuntu || cd /home/${USER} || { echo "‚ùå Project directory not found"; exit 1; }
            
            echo "üíæ Stashing local changes (if any)..."
            git stash || echo "‚ö†Ô∏è  No local changes to stash"
            
            echo "üì• Pulling latest code from repository..."
            git pull origin main || git pull origin master || { echo "‚ùå Git pull failed"; exit 1; }
            
            echo "üîê Setting up database password in environment..."
            if [ ! -f .env ]; then
              echo "DB_PASSWORD=${DB_PASSWORD}" > .env
            else
              if grep -q "^DB_PASSWORD=" .env; then
                sed -i "s|^DB_PASSWORD=.*|DB_PASSWORD=${DB_PASSWORD}|" .env
              else
                echo "DB_PASSWORD=${DB_PASSWORD}" >> .env
              fi
            fi
            
            echo "üîó Creating docker-compose.yml symlink..."
            ln -sf docker-compose.prod.yml docker-compose.yml
            
            echo "üê≥ Stopping and removing existing containers..."
            $SUDO docker compose down --remove-orphans || echo "‚ö†Ô∏è  No containers to stop"
            
            echo "üßπ Removing any orphaned containers..."
            $SUDO docker rm -f gstd_frontend gstd_backend gstd_gateway 2>/dev/null || true
            
            echo "üîÑ Rebuilding and starting containers..."
            $SUDO docker compose up -d --build --remove-orphans
            
            echo "üßπ Pruning unused Docker images..."
            $SUDO docker image prune -f
            
            echo "‚è≥ Waiting for services to start..."
            sleep 10
            
            echo "üìä Checking container status..."
            $SUDO docker compose ps
            
            echo "‚úÖ Deployment completed successfully!"
          DEPLOY_SCRIPT
      
      - name: Verify deployment
        env:
          SERVER_IP: ${{ env.SERVER_IP_ACTUAL }}
          SSH_USER: ${{ secrets.SSH_USER }}
        run: |
          echo "üîç Verifying deployment..."
          ssh -o StrictHostKeyChecking=no ${SSH_USER}@${SERVER_IP} << 'VERIFY_SCRIPT'
            cd /home/ubuntu || cd /home/${USER}
            
            SUDO=""
            if ! docker ps >/dev/null 2>&1; then sudo docker ps >/dev/null 2>&1 && SUDO="sudo"; fi
            
            echo "üìä Container status:"
            $SUDO docker compose ps
            echo ""
            echo "üìã Recent logs (last 20 lines):"
            $SUDO docker compose logs --tail=20 || true
          VERIFY_SCRIPT
