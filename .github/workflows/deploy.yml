name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Determine Server IP
        id: server_addr
        run: |
          # Robust logic to find the correct Server IP secret
          if [ -n "${{ secrets.SERVER_IP }}" ]; then
             echo "IP=${{ secrets.SERVER_IP }}" >> $GITHUB_OUTPUT
             echo "‚úÖ Using SERVER_IP"
          elif [ -n "${{ secrets.SSH_HOST }}" ]; then
             echo "IP=${{ secrets.SSH_HOST }}" >> $GITHUB_OUTPUT
             echo "‚ö†Ô∏è Using SSH_HOST fallback"
          else
             echo "‚ùå No Server IP found (SERVER_IP or SSH_HOST)"
             exit 1
          fi

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          # Pass ALL potential keys. The action handles empty lines/vars gracefully.
          # This avoids the "echo >> GITHUB_ENV" bug which corrupts multiline private keys.
          ssh-private-key: |
            ${{ secrets.SSH_PRIVATE_KEY }}
            ${{ secrets.SSH_KEY }}
      
      - name: Add server to known hosts
        env:
          SERVER_IP: ${{ steps.server_addr.outputs.IP }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "$SERVER_IP" >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Deploy to server
        env:
          SERVER_IP: ${{ steps.server_addr.outputs.IP }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          set -e
          echo "üöÄ Starting Deployment to $SERVER_IP..."
          
          # Safe injection of DB_PASSWORD using a temporary env file on remote
          # We use a heredoc passed to cat to avoid command line argument exposure/escaping issues
          ssh -o StrictHostKeyChecking=no ${SSH_USER}@${SERVER_IP} "cat > /tmp/deploy_env.sh" << EOF
          export DB_PASSWORD='${DB_PASSWORD}'
          EOF
          
          ssh -o StrictHostKeyChecking=no ${SSH_USER}@${SERVER_IP} "bash -s" << 'DEPLOY_SCRIPT'
            set -e
            
            # Load secrets safely
            source /tmp/deploy_env.sh
            rm -f /tmp/deploy_env.sh
            
            # --- Permission Check ---
            SUDO=""
            if ! docker ps >/dev/null 2>&1; then
                if sudo docker ps >/dev/null 2>&1; then
                    SUDO="sudo"
                    echo "‚ö†Ô∏è  Using sudo for Docker"
                else
                    echo "‚ùå Docker permission denied"
                    exit 1
                fi
            fi
            
            # --- Paths ---
            cd /home/ubuntu || { echo "‚ùå /home/ubuntu not found"; exit 1; }
            
            # --- Update Code ---
            echo "üì• Pulling code..."
            git stash >/dev/null 2>&1 || true
            git pull origin main || git pull origin master || { echo "‚ùå Git pull failed"; exit 1; }
            
            # --- Update Env ---
            echo "üîê Updating .env..."
            # Safely replace or append password
            if [ -f .env ]; then
                # Use temp file for safe sed
                cp .env .env.tmp
                if grep -q "^DB_PASSWORD=" .env.tmp; then
                    # Escape special chars in password for sed if needed, primarily / 
                    # Simpler strategy: grep -v then append
                    grep -v "^DB_PASSWORD=" .env.tmp > .env || true
                fi
                echo "DB_PASSWORD=${DB_PASSWORD}" >> .env
                rm -f .env.tmp
            else
                echo "DB_PASSWORD=${DB_PASSWORD}" > .env
            fi
            
            ln -sf docker-compose.prod.yml docker-compose.yml
            
            # --- Restart ---
            echo "‚ôªÔ∏è  Recreating containers..."
            $SUDO docker compose down --remove-orphans
            
            # Force cleanup of specific containers ensures no name conflicts
            $SUDO docker rm -f gstd_frontend gstd_backend gstd_gateway 2>/dev/null || true
            
            # Clean images
            $SUDO docker image prune -f
            
            # Start
            $SUDO docker compose up -d --build --remove-orphans
            
            # Verify
            echo "‚è≥ Waiting for health status..."
            sleep 10
            $SUDO docker compose ps
            
            echo "‚úÖ DEPLOY SUCCESS"
          DEPLOY_SCRIPT
