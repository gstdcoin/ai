name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Determine Server Config
        id: server_config
        run: |
          if [ -n "${{ secrets.SERVER_IP }}" ]; then
             echo "IP=${{ secrets.SERVER_IP }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ secrets.SSH_HOST }}" ]; then
             echo "IP=${{ secrets.SSH_HOST }}" >> $GITHUB_OUTPUT
          else
             echo "::error::server ip secret incorrect"
             exit 1
          fi

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{ secrets.SSH_PRIVATE_KEY }}
            ${{ secrets.SSH_KEY }}
      
      - name: Add to Known Hosts
        env:
          SERVER_IP: ${{ steps.server_config.outputs.IP }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H -t rsa,ed25519 "$SERVER_IP" >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Deploy
        env:
          SERVER_IP: ${{ steps.server_config.outputs.IP }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          set -e
          
          # Prepare Environment File Securely
          cat << EOF > env_update_script.sh
            export DB_PASSWORD='${DB_PASSWORD}'
          EOF
          
          scp -o StrictHostKeyChecking=no env_update_script.sh ${SSH_USER}@${SERVER_IP}:/tmp/deploy_env_vars.sh
          
          ssh -o StrictHostKeyChecking=no ${SSH_USER}@${SERVER_IP} "bash -s" << 'REMOTE_EXEC'
            set -e
            
            source /tmp/deploy_env_vars.sh
            rm -f /tmp/deploy_env_vars.sh
            
            TARGET_DIR="/home/ubuntu"
            cd $TARGET_DIR || cd /home/${USER} || { echo "‚ùå Directory not found"; exit 1; }
            
            # --- Permission Fix ---
            if sudo -n true 2>/dev/null; then
               sudo chown -R $USER:$USER .
            fi
            
            # --- Docker Permission Check ---
            DOCKER_CMD="docker"
            if ! docker ps >/dev/null 2>&1; then
                if sudo docker ps >/dev/null 2>&1; then
                    DOCKER_CMD="sudo docker"
                else
                    echo "‚ùå Docker permission error"
                    exit 1
                fi
            fi
            
            echo "üì• Syncing Code..."
            git stash >/dev/null 2>&1 || true
            git pull origin main || git pull origin master
            
            echo "üîê Updating Secrets..."
            # Update .env atomically
            if [ -f .env ]; then
                # Safe replacement using temporary file approach not strictly needed if we just append or use sed carefully
                sed -i '/^DB_PASSWORD=/d' .env
                echo "DB_PASSWORD='${DB_PASSWORD}'" >> .env
            else
                echo "DB_PASSWORD='${DB_PASSWORD}'" > .env
            fi
            
            ln -sf docker-compose.prod.yml docker-compose.yml
            
            echo "üîÑ Updating Images..."
            $DOCKER_CMD compose pull
            
            echo "‚ôªÔ∏è  Resetting Containers..."
            $DOCKER_CMD compose down --remove-orphans
            
            echo "üöÄ Starting Services..."
            $DOCKER_CMD compose up -d --build --remove-orphans
            
            echo "üßπ Deep Cleaning..."
            $DOCKER_CMD image prune -af
            
            echo "‚úÖ Health Check..."
            sleep 5
            $DOCKER_CMD compose ps
            
          REMOTE_EXEC
